
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';

// Your list of files to precache.
// This list is generated by Workbox during the build process in a real setup,
// but we define it manually here for clarity.
precacheAndRoute([
  { url: '/offline.html', revision: null },
  // Add other critical assets if needed, but the dynamic caching will handle most.
]);

// A new strategy for navigation requests: try the network first, but fall back to the offline page.
const navigationRoute = new NavigationRoute(
  new StaleWhileRevalidate({
    cacheName: 'pages-cache',
  }),
  {
    // Use the offline.html page as a fallback for navigation requests
    denylist: [/^\/_next\/static\//], // Exclude Next.js static assets from this rule
    allowlist: [{ url: new RegExp('/.*') }], // Match all navigation requests
  }
);

// A strategy for caching static assets (JS, CSS, images)
// Stale-While-Revalidate: serve from cache for speed, update in background.
const staticAssetsRoute = new StaleWhileRevalidate({
  cacheName: 'static-assets-cache',
  plugins: [
    // Ensure that we only cache successful responses
    {
      cacheableResponse: {
        statuses: [0, 200],
      },
    },
  ],
});

// A strategy for images - cache first for performance.
const imageRoute = new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
        {
            // Only cache images for 30 days
            expiration: {
                maxEntries: 60,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            },
        },
    ],
});


// Register the routes
registerRoute(navigationRoute);
registerRoute(({ request }) => request.destination === 'script' || request.destination === 'style', staticAssetsRoute);
registerRoute(({ request }) => request.destination === 'image', imageRoute);

self.addEventListener('install', (event) => {
    console.log('Service Worker: Installing...');
    event.waitUntil(
        caches.open('offline-fallback').then((cache) => {
            return cache.add('/offline.html');
        }).then(() => self.skipWaiting())
    );
});

self.addEventListener('activate', (event) => {
    console.log('Service Worker: Activating...');
    event.waitUntil(self.clients.claim());
});

self.addEventListener('fetch', (event) => {
    const { request } = event;
    // For navigation requests, try the network first. If it fails, serve the offline page.
    if (request.mode === 'navigate') {
        event.respondWith(
            fetch(request).catch(() => {
                return caches.match('/offline.html');
            })
        );
        return;
    }
    // For other requests, the registered routes will handle them.
});

